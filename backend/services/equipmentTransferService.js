const equipmentTransferRepository = require("../repositories/equipmentTransferRepository");
const equipmentTransferDetailRepository = require("../repositories/equipmentTransferDetailRepository");
const branchRepository = require("../repositories/branchRepository");
const equipmentUnitRepository = require("../repositories/equipmentUnitRepository");
const userRepository = require("../repositories/userRepository");
const equipmentService = require("./equipmentService");
const equipmentRepository = require("../repositories/equipmentRepository");

const equipmentTransferService = {
  // ===================================================
  // CREATE MULTI-TRANSFER
  // ===================================================
  createTransfer: async (data, userSub) => {
    if (!Array.isArray(data.unit_ids) || data.unit_ids.length === 0) {
      throw new Error("unit_ids must be a non-empty array");
    }

    if (!data.to_branch_id) {
      throw new Error("to_branch_id is required");
    }

    // ‚úÖ Ki·ªÉm tra t·ªìn t·∫°i chi nh√°nh ƒë√≠ch
    const toBranch = await branchRepository.findById(data.to_branch_id);
    if (!toBranch) throw new Error(`To branch ${data.to_branch_id} not found`);

    // ‚úÖ L·∫•y unit ƒë·∫ßu ti√™n ƒë·ªÉ x√°c ƒë·ªãnh chi nh√°nh ngu·ªìn
    const firstUnit = await equipmentUnitRepository.findById(data.unit_ids[0]);
    if (!firstUnit) throw new Error("Invalid first equipment unit");

    const from_branch_id = firstUnit.branch_id;
    if (!from_branch_id)
      throw new Error("Equipment unit does not have branch_id");

    // ‚úÖ Ki·ªÉm tra tr√πng chi nh√°nh
    if (from_branch_id === data.to_branch_id) {
      throw new Error("From branch and To branch cannot be the same");
    }

    // ‚úÖ Ki·ªÉm tra chi nh√°nh ngu·ªìn t·ªìn t·∫°i
    const fromBranch = await branchRepository.findById(from_branch_id);
    if (!fromBranch) throw new Error(`From branch ${from_branch_id} not found`);

    // ‚úÖ M√¥ t·∫£ chung
    const description = `Chuy·ªÉn ${data.unit_ids.length} thi·∫øt b·ªã t·ª´ ${fromBranch.name} sang ${toBranch.name}`;

    // ‚úÖ T·∫°o record master (Equipment_transfer)
    const transfer = await equipmentTransferRepository.create({
      from_branch_id,
      to_branch_id: data.to_branch_id,
      approved_by: userSub,
      description,
      move_start_date: data.move_start_date,
    });

    // ‚úÖ L·∫∑p qua t·ª´ng unit ‚Üí ki·ªÉm tra & t·∫°o TransferDetail
    const blockedStatuses = [
      "Inactive",
      "Temporary Urgent",
      "In Progress",
      "Ready",
      "Failed",
      "Deleted",
      "Moving",
    ];

    const details = [];
    for (const unitId of data.unit_ids) {
      const unit = await equipmentUnitRepository.findById(unitId);
      if (!unit) {
        console.warn(`‚ö†Ô∏è Unit ${unitId} not found. Skipped.`);
        continue;
      }

      const oldStatus = unit.status || "Unknown"; // üß© L∆∞u tr·∫°ng th√°i g·ªëc

      // ‚ùå Ki·ªÉm tra tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá
      if (blockedStatuses.includes(oldStatus)) {
        throw new Error(
          `Cannot transfer equipment unit ${unit.id} in status: ${oldStatus}`
        );
      }

      // ‚ùå Check chi nh√°nh kh√°c nhau
      if (unit.branch_id === data.to_branch_id) {
        throw new Error(
          `Unit ${unit.id} is already in destination branch ${data.to_branch_id}`
        );
      }

      // ‚úÖ Update unit sang tr·∫°ng th√°i Moving
      await equipmentUnitRepository.update(unit.id, {
        status: "Moving",
        description,
      });

      // ‚úÖ T·∫°o record TransferDetail
      const detail = await equipmentTransferDetailRepository.create({
        transfer_id: transfer.id,
        equipment_unit_id: unit.id,
      });

      // üß© ƒê√≠nh k√®m tr·∫°ng th√°i g·ªëc ƒë·ªÉ g·ª≠i email
      details.push({
        ...detail,
        old_status: oldStatus,
      });
    }

    return { transfer, details };
  },

  // ===================================================
  // üîç GET ALL TRANSFERS (BatchGet + Parallel)
  // ===================================================
  getTransfers: async (branchFilter = null) => {
    console.time("‚ö° getTransfers total");

    // 1Ô∏è‚É£ L·∫•y danh s√°ch transfers
    const transfers = branchFilter
      ? await equipmentTransferRepository.findByBranch(branchFilter)
      : await equipmentTransferRepository.findAll();

    if (!transfers.length) return [];

    // 2Ô∏è‚É£ L·∫•y to√†n b·ªô details song song
    const allDetails = await Promise.all(
      transfers.map((t) =>
        equipmentTransferDetailRepository.findByTransferId(t.id)
      )
    );
    const flatDetails = allDetails.flat();

    // 3Ô∏è‚É£ Gom to√†n b·ªô unit_id & equipment_id duy nh·∫•t
    const unitIds = [...new Set(flatDetails.map((d) => d.equipment_unit_id))];
    const units = unitIds.length
      ? await equipmentUnitRepository.batchFindByIds(unitIds)
      : [];
    const equipmentIds = [...new Set(units.map((u) => u.equipment_id))];
    const equipments = equipmentIds.length
      ? await equipmentRepository.batchFindByIds(equipmentIds)
      : [];

    // 4Ô∏è‚É£ T·∫°o map lookup nhanh
    const unitMap = Object.fromEntries(units.map((u) => [u.id, u]));
    const equipmentMap = Object.fromEntries(equipments.map((e) => [e.id, e]));

    // 5Ô∏è‚É£ Gom danh s√°ch user (duy·ªát + nh·∫≠n)
    const userSubs = [
      ...new Set(
        transfers.flatMap((t) => [t.approved_by, t.receiver_id]).filter(Boolean)
      ),
    ];
    const userResults = await Promise.all(
      userSubs.map((sub) => userRepository.getUserBySub(sub))
    );
    const userMap = Object.fromEntries(
      userSubs.map((sub, i) => [sub, userResults[i]])
    );

    // 6Ô∏è‚É£ Map detail theo transfer_id
    const detailMap = {};
    transfers.forEach((t, i) => {
      detailMap[t.id] = allDetails[i] || [];
    });

    // 7Ô∏è‚É£ Gh√©p d·ªØ li·ªáu cu·ªëi
    const results = transfers.map((t) => {
      const details = detailMap[t.id].map((d) => {
        const unit = unitMap[d.equipment_unit_id];
        const eq = equipmentMap[unit?.equipment_id];
        return {
          ...d,
          equipment_unit: {
            ...unit,
            equipment_name: eq?.name || null,
          },
        };
      });

      const approvedByUser = userMap[t.approved_by];
      const receiverUser = userMap[t.receiver_id];

      return {
        ...t,
        approved_by_name:
          approvedByUser?.attributes?.name || approvedByUser?.username || null,
        receiver_name:
          receiverUser?.attributes?.name || receiverUser?.username || null,
        details,
      };
    });

    console.timeEnd("‚ö° getTransfers total");
    return results;
  },

  // ===================================================
  // üîç GET TRANSFERS BY STATUS (BatchGet + Parallel)
  // ===================================================
  getTransfersByStatus: async (status, branchFilter = null) => {
    console.time("‚ö° getTransfersByStatus total");

    // 1Ô∏è‚É£ L·∫•y transfer theo status + l·ªçc branch
    const transfers = await equipmentTransferRepository.findAllByStatus(status);
    const filtered = branchFilter
      ? transfers.filter(
          (t) =>
            t.from_branch_id === branchFilter || t.to_branch_id === branchFilter
        )
      : transfers;
    if (!filtered.length) return [];

    // 2Ô∏è‚É£ L·∫•y to√†n b·ªô details song song
    const allDetails = await Promise.all(
      filtered.map((t) =>
        equipmentTransferDetailRepository.findByTransferId(t.id)
      )
    );
    const flatDetails = allDetails.flat();

    // 3Ô∏è‚É£ Gom to√†n b·ªô unit_id + equipment_id
    const unitIds = [...new Set(flatDetails.map((d) => d.equipment_unit_id))];
    const units = unitIds.length
      ? await equipmentUnitRepository.batchFindByIds(unitIds)
      : [];
    const equipmentIds = [...new Set(units.map((u) => u.equipment_id))];
    const equipments = equipmentIds.length
      ? await equipmentRepository.batchFindByIds(equipmentIds)
      : [];

    const unitMap = Object.fromEntries(units.map((u) => [u.id, u]));
    const equipmentMap = Object.fromEntries(equipments.map((e) => [e.id, e]));

    // 4Ô∏è‚É£ Gom user chung
    const userSubs = [
      ...new Set(
        filtered.flatMap((t) => [t.approved_by, t.receiver_id]).filter(Boolean)
      ),
    ];
    const userResults = await Promise.all(
      userSubs.map((sub) => userRepository.getUserBySub(sub))
    );
    const userMap = Object.fromEntries(
      userSubs.map((sub, i) => [sub, userResults[i]])
    );

    // 5Ô∏è‚É£ Map detail theo transfer_id
    const detailMap = {};
    filtered.forEach((t, i) => {
      detailMap[t.id] = allDetails[i] || [];
    });

    // 6Ô∏è‚É£ K·∫øt h·ª£p d·ªØ li·ªáu
    const results = filtered.map((t) => {
      const details = detailMap[t.id].map((d) => {
        const unit = unitMap[d.equipment_unit_id];
        const eq = equipmentMap[unit?.equipment_id];
        return {
          ...d,
          equipment_unit: {
            ...unit,
            equipment_name: eq?.name || null,
          },
        };
      });

      const approvedByUser = userMap[t.approved_by];
      const receiverUser = userMap[t.receiver_id];

      return {
        ...t,
        approved_by_name:
          approvedByUser?.attributes?.name || approvedByUser?.username || null,
        receiver_name:
          receiverUser?.attributes?.name || receiverUser?.username || null,
        details,
      };
    });

    console.timeEnd("‚ö° getTransfersByStatus total");
    return results;
  },

  // ===================================================
  // üîç GET ONE TRANSFER BY ID (BatchGet Units + Equipments)
  // ===================================================
  getTransferById: async (id) => {
    console.time("‚ö° getTransferById total");

    const transfer = await equipmentTransferRepository.findById(id);
    if (!transfer) throw new Error("EquipmentTransfer not found");

    // 1Ô∏è‚É£ L·∫•y to√†n b·ªô details c·ªßa transfer
    const details = await equipmentTransferDetailRepository.findByTransferId(
      id
    );
    if (!details.length) return { ...transfer, details: [] };

    // 2Ô∏è‚É£ BatchGet to√†n b·ªô Units
    const unitIds = details.map((d) => d.equipment_unit_id);
    const units = await equipmentUnitRepository.batchFindByIds(unitIds);

    // 3Ô∏è‚É£ BatchGet to√†n b·ªô Equipments
    const equipmentIds = [...new Set(units.map((u) => u.equipment_id))];
    const equipments = await equipmentRepository.batchFindByIds(equipmentIds);

    // 4Ô∏è‚É£ T·∫°o map nhanh
    const unitMap = Object.fromEntries(units.map((u) => [u.id, u]));
    const equipmentMap = Object.fromEntries(equipments.map((e) => [e.id, e]));

    // 5Ô∏è‚É£ Gh√©p d·ªØ li·ªáu
    const detailsWithUnits = details.map((d) => {
      const unit = unitMap[d.equipment_unit_id];
      const eq = equipmentMap[unit?.equipment_id];
      return {
        ...d,
        equipment_unit: {
          ...unit,
          equipment_name: eq?.name || null,
        },
      };
    });

    // 6Ô∏è‚É£ Song song l·∫•y user
    const [approvedByUser, receiverUser] = await Promise.all([
      transfer.approved_by
        ? userRepository.getUserBySub(transfer.approved_by)
        : null,
      transfer.receiver_id
        ? userRepository.getUserBySub(transfer.receiver_id)
        : null,
    ]);

    const result = {
      ...transfer,
      approved_by_name:
        approvedByUser?.attributes?.name || approvedByUser?.username || null,
      receiver_name:
        receiverUser?.attributes?.name || receiverUser?.username || null,
      details: detailsWithUnits,
    };

    console.timeEnd("‚ö° getTransferById total");
    return result;
  },

  // ===================================================
  // ‚úÖ COMPLETE TRANSFER
  // ===================================================
  completeTransfer: async (id, move_receive_date, userSub) => {
    const existing = await equipmentTransferRepository.findById(id);
    if (!existing) throw new Error("EquipmentTransfer not found");

    // ‚ùå Kh√¥ng cho ph√©p complete n·∫øu ƒë√£ completed
    if (existing.status === "Completed") {
      throw new Error("Transfer already completed");
    }

    // ‚úÖ Ho√†n t·∫•t record master
    const transfer = await equipmentTransferRepository.complete(
      id,
      move_receive_date,
      userSub
    );

    // ‚úÖ L·∫•y chi nh√°nh ƒë√≠ch
    const toBranch = await branchRepository.findById(existing.to_branch_id);
    if (!toBranch) {
      throw new Error(`Branch ${existing.to_branch_id} not found`);
    }

    // ‚úÖ L·∫•y to√†n b·ªô chi ti·∫øt
    const details = await equipmentTransferDetailRepository.findByTransferId(
      id
    );

    // ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i cho t·ª´ng unit
    const description = `Transferred to branch ${toBranch.name}`;
    for (const d of details) {
      await equipmentUnitRepository.update(d.equipment_unit_id, {
        branch_id: existing.to_branch_id,
        status: "In Stock",
        description,
      });
    }

    return { transfer, details };
  },

  // ===================================================
  // üóë DELETE TRANSFER
  // ===================================================
  deleteTransfer: async (id) => {
    const existing = await equipmentTransferRepository.findById(id);
    if (!existing) throw new Error("EquipmentTransfer not found");
    return await equipmentTransferRepository.delete(id);
  },
};

module.exports = equipmentTransferService;
